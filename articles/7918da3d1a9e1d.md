---
title: "MagicOnion + MessgePack + YetAnotherHttpHandler でリアルタイム通信を行う"
emoji: "🕌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# 概要
Grpc.Net 実装の YetAnotherHttpHandler がリリースされたので、最新の環境で MagicOnion + MessagePack でリアルタイム通信やるかぁ～と思ったのがきっかけです。経緯はこちら。
[Unityでもgrpc-dotnetを使ったgRPCがしたい - Activ8 Tech Blog](https://synamon.hatenablog.com/entry/grpc-dotnet-unity)

環境構築する上で、最新バージョンの利用だったり、リアルタイム通信用の StreamingHub の実装だったり、 MessagePack や MagicOnion のコード生成だったり、IL2CPP ビルドをしたり、TLS 化するなどしたり、で意外とハマりポイントがあったので、記事として残しておきます。


また、MagicOnion ネタとして、以下のシリーズで記事を書けたらいいなぁと思っています。

- MagicOnion + MessgePack + YetAnotherHttpHandlerでリアルタイムサーバーを作る（本記事） 
- 自己証明書で MagicOnion Server を SSL/TLS 化
- MagicOnion + MessagePack + grpc.core handler でリアルタイムサーバーを作る
- 自己証明書のカスタム検証ロジックを追加する(grpc.core handler バージョン)
- MagicOnion Server を GCP にデプロイする
  - MagicOnion Server を docker コンテナで動かす
- DFrame で MagicOnion Server の負荷試験
- リバースプロキシでSSL終端


# 環境
- .NET SDK8.0
  - [.NET 8.0 (Linux、macOS、Windows) をダウンロードする](https://dotnet.microsoft.com/ja-jp/download/dotnet/8.0)
  - インストールしておきましょう
  - .NET 7 以降で Linux 上のパフォーマンスや gRPC のパフォーマンスが上がったらしく、LTS 版の .NET8 を使います
- Unity2022.3.14f1
  - これより新しいバージョンであれば大丈夫なはず
- MagicOnion 5.1.8
  - [Cysharp/MagicOnion: Unified Realtime/API framework for .NET platform and Unity.](https://github.com/Cysharp/MagicOnion)
  - リアルタイムサーバー用途として利用できるフレームワーク
- MessagePack 2.5.140
  - [GitHub - MessagePack-CSharp/MessagePack-CSharp: Extremely Fast MessagePack Serializer for C#(.NET, .NET Core, Unity, Xamarin). / msgpack.org[C#]](https://github.com/MessagePack-CSharp/MessagePack-CSharp)
  - C#用のめっちゃ速いシリアライザ

# 流れ
- MagicOnion Server 編
  - Shared プロジェクト
  - Server プロジェクトの準備
- Unityクライアント編
  - Unity Package の追加
  - NuGet Package の追加
  - Grpc.NET の設定
  - コード生成
- UI の生成
- IL2CPP ビルドの設定

# MagicOnion Server プロジェクト

GitHub 上のリポジトリはこちらです。


## 事前準備
- .NET SDK8.0 のダウンロード
  - [.NET 8.0 (Linux、macOS、Windows) をダウンロードする](https://dotnet.microsoft.com/ja-jp/download/dotnet/8.0)
- Editor の更新
  - .NET8 対応のために Visual Studio や Rider の更新が必要になると思います。


## 最初のフォルダー構成

```
magiconion-sample-server
├── .git
├── .gitignore
└── README.md

```

.gitignore は GitHub を参考にしてください。
[magiconion-sample-server/.gitignore at main · tou-tou/magiconion-sample-server](https://github.com/tou-tou/magiconion-sample-server/blob/main/.gitignore)

## ソリューションの作成

以下のようなコマンドで.NET ソリューションと2つのプロジェクトを作成し、ソリューションに2つのプロジェクトを追加します。
2つのプルジェクトのうち、
1つは Server プロジェクトで MagicOnion Server の実装を置くプロジェクトです。
2つめは Server と Unityクライアントで共有する Shared プロジェクトで、Interface群が定義されています。
Server 側でこの Interface を実装し、client 側ではこの Interface を利用するという関係になります。

```shell:powershell
> cd magiconion-sample-server
> dotnet new sln -n magiconion-sample-server
> dotnet new console -n Server -o magiconion-sample-server --framework net8.0
> dotnet sln magiconion-sample-server.sln add Server/Server.csproj
> dotnet new classlib -n Shared -o magiconion-sample-server
> dotnet sln magiconion-sample-server.sln add Shared/Shared.csproj
```


また、Server プロジェクトは最新の .NET 8 を指定します。.NET 7 以降で Linux 上のパフォーマンスや gRPC のパフォーマンスが上がったらしく、LTS 版の .NET8 を使いたいです。 docker コンテナ環境で実行するときの .NET6 と .NET8 でのパフォーマンス差が気になるところです。（比較記事を書きたい）


`magiconion-sample-server.sln`をExplorererからダブルクリックするなりして開きます

以下のようなディレクトリ構成になっているはずです。

```
magiconion-sample-server
├── .git
├── .gitignore
├── README.md
├── Server
│   ├── Program.cs
│   └── Server.csproj
├── Shared
│   ├── Class1.cs
│   └── Shared.csproj
└── magiconion-sample-server.sln

```

また、Shared プロジェクトはサーバー側では .NET8 環境、Unity クライアント側では Unity のコンパイラ環境で実行されるので注意が必要です。

そのため Shared プロジェクトに関して、 以下のように`LangVersion`を`9.0`で指定しておきます。Unity コンパイラが C# 9.0 までしか対応していないためです。Server プロジェクトは .NET8 なので C#12 まで使えますが、その構文で Shared プロジェクトの中身を書くと Unity 実行時でコンパイルエラーが出る可能性があります。

```csproj:Shared.csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <LangVersion>9.0</LangVersion>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

```



## Shared プロジェクトで Interface 定義
まずは、shared プロジェクトの Interface を定義します。この shared プロジェクトで定義した Interface は Server プロジェクトで実装されます。一方クライアント側からこの Interface を呼び出しことになります。


まずは `shared.csproj`に必要な package を以下のように追加します。

```
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
     <LangVersion>9.0</LangVersion>
    <ImplicitUsings>enable</ImplicitUsings> 
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="MagicOnion.Abstractions" Version="5.1.8" />
    <PackageReference Include="MessagePack" Version="2.5.140" />
    <PackageReference Include="MessagePack.UnityShims" Version="2.5.140" />
  </ItemGroup>

</Project>
```


MagicOnion の [README](https://github.com/Cysharp/MagicOnion?tab=readme-ov-file#quick-start) を参考に`Interface`を追加します。Shared ディレクトリ配下に`Interfaces`ディレクトリを追加し、その配下に以下の `IMyFirstService.cs`と`IGamingHub.cs`を追加します。


```cs:IMyFirstService
using MagicOnion;
namespace Shared.Interfaces
{
    public interface IMyFirstService : IService<IMyFirstService>
    {
        UnaryResult<int> SumAsync(int x, int y);
    }
}
```

```cs:IGamingHub
using System.Threading.Tasks;
using MagicOnion;
using MessagePack;
using UnityEngine;

namespace Shared.Interfaces
{
    public interface IGamingHubReceiver
    {
        void OnJoin(Player player);
        void OnLeave(Player player);
        void OnMove(Player player);
    }
    
    public interface IGamingHub : IStreamingHub<IGamingHub, IGamingHubReceiver>
    {
        ValueTask<Player[]> JoinAsync(string roomName, string userName, Vector3 position, Quaternion rotation);
        ValueTask LeaveAsync();
        ValueTask MoveAsync(Vector3 position, Quaternion rotation);
    }
    
    [MessagePackObject]
    public class Player
    {
        [Key(0)]
        public string Name { get; set; }
        [Key(1)]
        public Vector3 Position { get; set; }
        [Key(2)]
        public Quaternion Rotation { get; set; }
    }
}
```

次に、Unity において Shared プロジェクトを package として認識できるように、Shared プロジェクトルートに package.json を追加します。


```json:package.json
{
  "name": "com.magiconion-sample-server.shared",
  "version": "0.0.1",
  "displayName": "magiconion-sample-server shared"
}
```


さらに不要なClass1.csは削除すると、Shared 以下のディレクトリ構造は以下のようになっているはずです。

```
Shared
├── Interfaces
│   ├── IGamingHub.cs
│   └── IMyFirstService.cs
├── Shared.csproj
└── package.json
```


## Server プロジェクトで Interface の実装

以下のようにプロジェクトファイルに MagicOnion.Server 5.1.8 と Shared プロジェクトの package を追加します。

```csproj:Server.csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="MagicOnion.Server" Version="5.1.8"/>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="../Shared/Shared.csproj"/>
  </ItemGroup>
  
</Project>

```

### Server プロジェクトで Interface の実装


MagicOnion の [README](https://github.com/Cysharp/MagicOnion#service-implementation-server-side) の通り`MyFistService.cs`と`GamingHub.cs`として実装します。
ディレクトリ構造は以下のようにします。

```bash
Server
├── Program.cs
├── Server.csproj
├── Services
│   └── MyFirstService.cs
└─── StreamingHub
   └── GamingHub.cs

```
```cs:MyFirstService.cs
using MagicOnion;
using MagicOnion.Server;
using Shared.Interfaces;

namespace Server.Services;

// copied from https://github.com/Cysharp/MagicOnion#service-implementation-server-side
// Implements RPC service in the server project.
// The implementation class must inherit `ServiceBase<IMyFirstService>` and `IMyFirstService`
public class MyFirstService : ServiceBase<IMyFirstService>, IMyFirstService
{
    // `UnaryResult<T>` allows the method to be treated as `async` method.
    public async UnaryResult<int> SumAsync(int x, int y)
    {
        Console.WriteLine($"Received:{x}, {y}");
        return x + y;
    }
}

```

```cs:GamingHub.cs
using MagicOnion.Server.Hubs;
using Shared.Interfaces;
using UnityEngine;

namespace Server.StreamingHub;

// copied from https://github.com/Cysharp/MagicOnion#streaminghub
// Server implementation
// implements : StreamingHubBase<THub, TReceiver>, THub
public class GamingHub : StreamingHubBase<IGamingHub, IGamingHubReceiver>, IGamingHub
{
    // this class is instantiated per connected so fields are cache area of connection.
    IGroup room;
    Player self;
    IInMemoryStorage<Player> storage;

    public async ValueTask<Player[]> JoinAsync(string roomName, string userName, Vector3 position, Quaternion rotation)
    {
        self = new Player() { Name = userName, Position = position, Rotation = rotation };

        // Group can bundle many connections and it has inmemory-storage so add any type per group.
        (room, storage) = await Group.AddAsync(roomName, self);

        // Typed Server->Client broadcast.
        Broadcast(room).OnJoin(self);

        return storage.AllValues.ToArray();
    }

    public async ValueTask LeaveAsync()
    {
        await room.RemoveAsync(this.Context);
        Broadcast(room).OnLeave(self);
    }

    public async ValueTask MoveAsync(Vector3 position, Quaternion rotation)
    {
        self.Position = position;
        self.Rotation = rotation;
        Console.WriteLine($"MoveAsync: {self.Name} pos:{position.x} {position.y} {position.z} rot:{rotation.x} {rotation.y} {rotation.z} {rotation.w}");
        Broadcast(room).OnMove(self);
    }

    // You can hook OnConnecting/OnDisconnected by override.
    protected override ValueTask OnDisconnected()
    {
        // on disconnecting, if automatically removed this connection from group.
        return ValueTask.CompletedTask;
    }
}
```

### サーバープログラムのエントリポイントの実装

以下の点を考慮しています。
- 問題の切り分け用に HTTP/1.1 のエンドポイントを用意しておく
- エンドポイントのIPは `0.0.0.0`にしているのは、docker コンテナ上で Server を起動したときにホストマシンからのアクセスを楽にするため
  - なのでホストマシンでサーバーを起動する場合は`127.0.0.1`でも大丈夫
- 証明書を読み込むオプションがあるが、現時点では証明書を生成していないので機能しないです。

```cs:Program.cs
using System.Net;
using System.Security.Cryptography.X509Certificates;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Server.Kestrel.Core;
using Microsoft.Extensions.DependencyInjection;

namespace Server;

internal static class Program
{
    public static void Main(string[] args)
    {
        var builder = WebApplication.CreateBuilder(args);
        
        builder.WebHost.UseKestrel(options =>
        {
            options.ConfigureEndpointDefaults(endpointOptions =>
            {
                endpointOptions.Protocols = HttpProtocols.Http2;
            });
            
            // HTTP/1.1エンドポイントの設定
            options.Listen(IPAddress.Parse("0.0.0.0"), 8000, listenOptions =>
            {
                listenOptions.Protocols = HttpProtocols.Http1;
            });
            
            // HTTP/2 ,HTTPS エンドポイントの設定
            options.Listen(IPAddress.Parse("0.0.0.0"),5000, listenOptions =>
            {
                // --load-cert=true が指定されていたら証明書を読み込む
                if (args.Any(arg => arg == "--load-cert=true"))
                {
                    Console.WriteLine("load certificate");
                    listenOptions.UseHttps(new X509Certificate2("certificate/certificate.pfx","test"));
                }
            });
        });
        
        builder.Services.AddGrpc();
        builder.Services.AddMagicOnion();

        var app = builder.Build();
        
        // テスト用のエンドポイント
        app.MapGet("/", () => "Hello World!");
        
        // MagicOnionのエンドポイント
        app.MapMagicOnionService();

        app.Run();
    }
}

```

GitHub リポジトリに push しておきます。
```
git push origin main
```



# クライアント編

## 下準備
- UnityHub から適当な Unity プロジェクトを作成
  - 自分は URPの3Dテンプレートにしました。
- .gitignore, .gitattributeを追加
  - [magiconion-sample-client/.gitignore](https://github.com/tou-tou/magiconion-sample-client/blob/main/.gitignore)
  - [magiconion-sample-client/.gitattributes](https://github.com/tou-tou/magiconion-sample-client/blob/main/.gitattributes)
- `git init`でローカル git リポジトリを作成


## 必要な Unity Package を openupm 経由で追加

OpneUPMとは、...

Packagesフォルダ配下に `scopedRegistries`として以下を追加します。
```json:manifest.json
"scopedRegistries": [
    {
      "name": "package.openupm.com",
      "url": "https://package.openupm.com",
      "scopes": [
        "com.cysharp.magiconion",
        "com.neuecc.messagepack",
        "com.cysharp.yetanotherhttphandler",
        "com.veriorpies.parrelsync"
      ]
    }
  ],
```


`dependencies`として以下を追加します。

```json:manfest.json
 "dependencies": {
    "com.cysharp.magiconion": "5.1.8",
    "com.neuecc.messagepack": "2.5.140",
    "com.cysharp.yetanotherhttphandler": "0.1.0",
    "com.github-glitchenzo.nugetforunity": "4.0.2",
    "com.veriorpies.parrelsync": "1.5.2",
    "com.magiconion-sample-server.shared": "file:../../magiconion-sample-client/magiconion-sample-server/Shared/",
 ...
 }
```

- [ParrelSync](https://github.com/VeriorPies/ParrelSync)は Unity Editor を複数立ち上げてマルチプレイのデバッグができる拡張ツールです。
- `"com.magiconion-sample-server.shared": "file:../../magiconion-sample-client/magiconion-sample-server/Shared/",`を指定して Shared プロジェクトを読み込みます。
  - `"file:../../magiconion-sample-client/magiconion-sample-server/Shared/"` file のパス指定で2つ上の親ディレクトリまで戻っているのでは ParrelSync を正常に動かすためです。
- [NuGetForUnity: A NuGet Package Manager for Unity](https://github.com/GlitchEnzo/NuGetForUnity)
  - これを使うと `.unitypacakge`ファイルを import して dll を読み込むみたいなことをしなくて済みます。
  - パッケージのバージョン管理もしてくれるので管理が楽になります。


## 必要な NuGet Pacakge を追加
NuGetPackgeとは...

まずは、 yetanotherhttphandler の依存関係を NuGetForUnityで追加します。

必要なライブラリをGUIでポチポチと追加するか Assets/package.config に以下を記述してライブラリを追加します。

さらにMessagePack 2.5.140 は`Microsoft.NET.StringTools`のv1.0.0に依存しているので追加します。

```config:package.config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Grpc.Core.Api" version="2.55.0" />
  <package id="Grpc.Net.Client" version="2.55.0" manuallyInstalled="true" />
  <package id="Grpc.Net.Common" version="2.55.0" />
  <package id="Microsoft.Extensions.Logging.Abstractions" version="3.0.3" />
  <package id="Microsoft.NET.StringTools" version="1.0.0" manuallyInstalled="true" />
  <package id="System.Diagnostics.DiagnosticSource" version="4.5.1" />
  <package id="System.IO.Pipelines" version="7.0.0" manuallyInstalled="true" />
  <package id="System.Runtime.CompilerServices.Unsafe" version="5.0.0" manuallyInstalled="true" />
</packages>
```


## エラーの解消
- Grpc.Coreの依存エラーがでる
  - `Assets\Scripts\MagicOnion\MagicOnion.Unity\UnityDebugLogger.cs(2,17): error CS0234: The type or namespace name 'Logging' does not exist in the namespace 'Grpc.Core' (are you missing an assembly reference?)`
  - ![](https://storage.googleapis.com/zenn-user-upload/8147c9ad86de-20231029.png)
- `Assets\Scripts\MagicOnion\MagicOnion.Unity\GrpcChannelProvider.cs(174,47): error CS0246: The type or namespace name 'GrpcCCoreGrpcChannelProvider' could not be found (are you missing a using directive or an assembly reference?)
`
  - ![](https://storage.googleapis.com/zenn-user-upload/65a32de412f7-20231029.png)
- Projectsettings -> Player -> Script Compilationで Scripting Define Synbolsから
  - `USE_GRPC_NET_CLIENT_ONLY`と`USE_GRPC_NET_CLIENT`を追加

```
Library\PackageCache\com.neuecc.messagepack@2.5.140\Formatters\StringInterningFormatter.cs(5,17): error CS0234: The type or namespace name 'NET' does not exist in the namespace 'Microsoft' (are you missing an assembly reference?)
```
`Microsoft.NET.StringTools`v1.0.0をNuGetForUnityから追加

## Shared プロジェクトに AssemblyDefinition ファイルを追加

サーバー側では csproj ファイルでパッケージ依存関係を解決していましたが、Unity 側ではパッケージ依存関係の解決のために Assembly Definition ファイルを使います。

Unity Editor から AssemblyDefinitions ファイルを追加して Assembly Deffinition References に `MessagePack.Annotations`と`MagicOnion.Abstractions`を追加します。これによって、Shared プロジェクトで必要な MagicOnion や MessagePack を読み込むことができます。

![Alt text](image-1.png)

その後、Submoduleのmagiconion-sample-serverプロジェクト（実体は git ローカルリポジトリ）内で以下のように変更をリモートリポジトリに push しておきましょう。 

```powershell:powershell
path-to\magiconion-sample-client > cd magiconion-sample-server
path-to\magiconion-sample-client\magiconion-sample-server> git status
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        Shared/Shared.asmdef
> git add Shared/Shared.asmdef
> git commit -m "add asmdef"
> git push origin main

```

 
 ## 実装
 ```cs:GamingHubClient.cs
using System.Collections.Generic;
using System.Threading.Tasks;
using Grpc.Core;
using MagicOnion.Client;
using Shared.Interfaces;
using UnityEngine;

namespace SampleClient
{
    public class GamingHubClient : IGamingHubReceiver
    {
        Dictionary<string, GameObject> _players = new Dictionary<string, GameObject>();

        IGamingHub _client;
        
        private readonly GameObject _ownPlayer;
        
        public GamingHubClient(GameObject player)
        {
            _ownPlayer = player;
        }

        public async ValueTask<GameObject> ConnectAsync(ChannelBase grpcChannel, string roomName, string playerName)
        {
            this._client = await StreamingHubClient.ConnectAsync<IGamingHub, IGamingHubReceiver>(grpcChannel, this);

            var roomPlayers = await _client.JoinAsync(roomName, playerName, Vector3.zero, Quaternion.identity);
            foreach (var player in roomPlayers)
            {
                (this as IGamingHubReceiver).OnJoin(player);
            }

            return _players[playerName];
        }

        // methods send to server.

        public ValueTask LeaveAsync()
        {
            return _client.LeaveAsync();
        }

        public ValueTask MoveAsync(Vector3 position, Quaternion rotation)
        {
            // たまにnullになることがあるので、nullチェックを入れる
            if (_client == null) return new ValueTask();
            return _client.MoveAsync(position, rotation);
        }

        // dispose client-connection before channel.ShutDownAsync is important!
        public Task DisposeAsync()
        {
            return _client.DisposeAsync();
        }

        // You can watch connection state, use this for retry etc.
        public Task WaitForDisconnect()
        {
            return _client.WaitForDisconnect();
        }

        // Receivers of message from server.

        void IGamingHubReceiver.OnJoin(Player player)
        {
            Debug.Log("Join Player:" + player.Name);

            // 自身の場合は自分のオブジェクトを生成しない
            if (_ownPlayer.name == player.Name)
            {
                _players[player.Name] = _ownPlayer;
            }
            else
            {
                var playerObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
                playerObject.name = player.Name;
                playerObject.transform.SetPositionAndRotation(player.Position,player.Rotation);
                _players[player.Name] = playerObject;
            }
        }

        void IGamingHubReceiver.OnLeave(Player player)
        {
            Debug.Log("Leave Player:" + player.Name);

            if (_players.TryGetValue(player.Name, out var cube))
            {
                GameObject.Destroy(cube);
            }
        }

        void IGamingHubReceiver.OnMove(Player player)
        {
            Debug.Log("Move Player:" + player.Name);

            if (_players.TryGetValue(player.Name, out var cube))
            {
                if (player.Name == _ownPlayer.name) return;
                cube.transform.SetPositionAndRotation(player.Position, player.Rotation);
            }
        }
    }
}
 ```


 ```cs:Sample.cs
 using Cysharp.Net.Http;
using Shared.Interfaces;
using Grpc.Net.Client;
using MagicOnion.Client;
using UnityEngine;

namespace SampleClient
{
    public class Sample : MonoBehaviour
    {
        [SerializeField] GameObject actor;
        private GamingHubClient _hubClient;
        async void Start()
        {
            var handler = new YetAnotherHttpHandler()
            {
                Http2Only = true,
            };
            
            var options = new GrpcChannelOptions
            {
                HttpHandler = handler,
            };
            
            var channel = GrpcChannel.ForAddress("http://127.0.0.1:5000/", options);
            
            var serviceClient = MagicOnionClient.Create<IMyFirstService>(channel);
            _hubClient = new GamingHubClient(actor);
            var _ = await _hubClient.ConnectAsync(channel,"room1" ,this.name);
            
            var result = await serviceClient.SumAsync(100, 200);
            Debug.Log(result);
        }
        
        private async void Update()
        {
            var position = actor.transform.position;
            var rotation = actor.transform.rotation;
            await _hubClient.MoveAsync(position,rotation);
        }

        private async void OnDestroy()
        {
            await _hubClient.LeaveAsync();
            await _hubClient.DisposeAsync();
        }
    }
}
 ```

 ## コード生成

### MOC
https://github.com/Cysharp/MagicOnion?tab=readme-ov-file#moc-magiconion-codegen-command-line-tool

```
Assets> dotnet new tool-manifest
Assets> dotnet tool install MagicOnion.Generator
Assets> dotnet moc -i ../Shared.csproj -o Scripts/Generated/MagicOnion.Generated.cs
```

### MPC

![Alt text](image.png)

![Alt text](image-2.png)


## Initializer

```cs:initializer.cs
using Grpc.Net.Client;
using MagicOnion.Unity;
using MessagePack;
using MessagePack.Resolvers;
using UnityEngine;

namespace SampleClient
{
    public static class Initializer
    {
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        public static void OnRuntimeInitialize()
        {
            // Initialize gRPC channel provider when the application is loaded.
            GrpcChannelProviderHost.Initialize(new DefaultGrpcChannelProvider(new GrpcChannelOptions()));
        }

        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        static void RegisterResolvers()
        {
            // NOTE: Currently, CompositeResolver doesn't work on Unity IL2CPP build. Use StaticCompositeResolver instead of it.
            StaticCompositeResolver.Instance.Register(
                // This resolver is generated by MagicOnion's code generator.
                MagicOnion.Resolvers.MagicOnionResolver.Instance,
                // This resolver is generated by MessagePack's code generator.
                MessagePack.Resolvers.MagicOnionSampleResolver.Instance,
                BuiltinResolver.Instance,
                PrimitiveObjectResolver.Instance,
                MessagePack.Unity.UnityResolver.Instance,
                StandardResolver.Instance
            );

            MessagePackSerializer.DefaultOptions = MessagePackSerializer.DefaultOptions
                .WithResolver(StaticCompositeResolver.Instance);
        }
    }
}
```

# UI の生成

[ UI ToolKitを導入して効率よくUIを構築する ](https://forpro.unity3d.jp/unity_pro_tips/2022/04/21/3629/)をベースに簡単なUIを作ります。

# ビルド
il2cpp
player settings ->
![Alt text](image-3.png)

バックグラウンドでも動くように
![Alt text](image-4.png)

画像を可変に
![Alt text](image-5.png)


```
Internal build system error. BuildProgram exited with code 1.
error: Could not set up a toolchain for Architecture x64. Make sure you have the right build tools installed for il2cpp builds. Details:
IL2CPP C++ code builder is unable to build C++ code. In order to build C++ code for Windows Desktop, you must have one of these installed:
 * Visual Studio 2022 or newer with C++ compilers and Windows 10 (or newer) SDK (recommended)
 * Visual Studio 2019 with C++ compilers and Windows 10 (or newer) SDK
 * Visual Studio 2017 with C++ compilers and Windows 10 (or newer) SDK
 * Visual Studio 2015 with C++ compilers and Windows 10 (or newer) SDK

Visual Studio 2017 (or newer) is detected using `vswhere.exe` as well as VSCOMNTOOLS environment variables.
Visual Studio 2015 is detected by looking at "SOFTWARE\Microsoft\VisualStudio\14.0_Config\InstallDir" in the registry as well as VSCOMNTOOLS environment variables.
Windows 10 (or newer) SDK is detected by looking at "SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\Windows\v10.0\InstallationFolder" in the registry.

Unable to detect any compatible Visual Studio installation!
 * Found Visual Studio 2022 installation without C++ tool components
 * Found Visual Studio 2019 installation without C++ tool components

Windows 10 (or newer) SDK is not installed. You can install from here: https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk/


Unity.IL2CPP.Bee.BuildLogic.ToolchainNotFoundException: IL2CPP C++ code builder is unable to build C++ code. In order to build C++ code for Windows Desktop, you must have one of these installed:
 * Visual Studio 2022 or newer with C++ compilers and Windows 10 (or newer) SDK (recommended)
 * Visual Studio 2019 with C++ compilers and Windows 10 (or newer) SDK
 * Visual Studio 2017 with C++ compilers and Windows 10 (or newer) SDK
 * Visual Studio 2015 with C++ compilers and Windows 10 (or newer) SDK

Visual Studio 2017 (or newer) is detected using `vswhere.exe` as well as VSCOMNTOOLS environment variables.
Visual Studio 2015 is detected by looking at "SOFTWARE\Microsoft\VisualStudio\14.0_Config\InstallDir" in the registry as well as VSCOMNTOOLS environment variables.
Windows 10 (or newer) SDK is detected by looking at "SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\Windows\v10.0\InstallationFolder" in the registry.

Unable to detect any compatible Visual Studio installation!
 * Found Visual Studio 2022 installation without C++ tool components
 * Found Visual Studio 2019 installation without C++ tool components

Windows 10 (or newer) SDK is not installed. You can install from here: https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk/


   at Unity.IL2CPP.Bee.BuildLogic.WindowsDesktop.WindowsDesktopBuildLogic.UserAvailableToolchainFor(Architecture architecture, NPath toolChainPath, NPath sysRootPath, Boolean targetIsSimulator)
   at PlayerBuildProgramLibrary.PlayerBuildProgramBase.GetIl2CppToolChain(PlatformBuildLogic platform, Architecture architecture, NPath toolChainPath, NPath sysrootPath)
   at PlayerBuildProgramLibrary.PlayerBuildProgramBase.SetupIl2CppBuild()
   at PlayerBuildProgramLibrary.PlayerBuildProgramBase.<SetupPlayerBuild>b__94_0()
   at Bee.Core.TinyProfiler2Base.Section[T](String label, Func`1 func, Dictionary`2 metadata)
   at PlayerBuildProgramLibrary.PlayerBuildProgramBase.SetupPlayerBuild()
   at WinPlayerBuildProgram.WinPlayerBuildProgram.SetupPlayerBuild()
   at PlayerBuildProgramLibrary.PlayerBuildProgramBase.RunBuildProgram()
   at PlayerBuildProgramTypeWrapper.Run(String[] args)
   at Program.Main(String[] args)
UnityEngine.GUIUtility:ProcessEvent (int,intptr,bool&)
```


## マテリアルの設定

URPプロジェクトのデフォルトのマテリアル`Universal Render Pipeline/Lit` shader がなぜかビルド後のアプリケーションで参照がはがれてしまっているので、`Universal Render Pipeline/Unlit`のマテリアルを使います。（上記の問題）



![Alt text](image-6.png)

![Alt text](image-7.png)

![Alt text](image-8.png)

Resources フォルダにURPLitマテリアルを追加します。
（ビルドではCreatePrimitiveで期待通りにmaterialがアタッチされないっぽい）

# 参考記事
- [UnityMagicOnion導入方法(2023年最新) #C# - Qiita](https://qiita.com/KyoheiOkawa/items/63a68bbcc3caaaac581e)
- [YetAnotherHttpHandlerをMagicOnionで導入する方法 #C# - Qiita](https://qiita.com/KyoheiOkawa/items/2d54551b59e22e2536bf#unity%E3%82%AF%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%B3%E3%83%88%E3%82%B3%E3%83%BC%E3%83%89)
- [UnityとC#で簡単にgRPCする in 2023](https://zenn.dev/turing_motors/articles/7f5cc78c5d5b55)
- 
