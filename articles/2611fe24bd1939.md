---
title: "Unity(YetAnotherHttpHandler)とMagicOnionで自己署名証明書を使ったHTTPS&HTTP/2通信してみた"
emoji: "🙌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Unity","MagicOnion","HTTP2","https","自己証明書",]
published: false
---

# 概要

[MagicOnion + MessagePack + YetAnotherHttpHandler でリアルタイム通信を行う](https://zenn.dev/toutou/articles/7918da3d1a9e1d) の続編です。
自己署名証明書を使って Unity(YetAnotherHttpClient)とリアルタイムサーバー（MagicOnion）で HTTPS & HTTP/2 通信する手順を紹介します。

基本は[Configure SSL/TLS | MagicOnion](https://cysharp.github.io/MagicOnion/articles/deployment/https.html#tls-on-localhost) の通りですが、ちょっと躓いた部分があったので、うまくいった方法を紹介させていただきます。

以前は、標準のhandlerでカスタム検証ロジックを追加して証明書検証をすることができたのですが、カスタム検証ロジックが追加できない代わりに、ルート証明書を渡すことでちゃんと検証してくれます。
YetAnotherHttpHandler がしっかりと証明書の検証をやってくれます。

https://cysharp.github.io/MagicOnion/articles/deployment/https.html#tls-on-localhost

# 環境
## 開発環境
- Windows 11
- WSL 2
  - [WSL のインストール | Microsoft Learn](https://learn.microsoft.com/ja-jp/windows/wsl/install)
  - Ubuntu 20.04
    - WSL の Linux ディストリビューションとして上記を使っていましたが、OpenSSL 3 系が使える Linux ディストリビューションであればなんでもよいです。
    - OpenSSL で自己証明書を発行します。 

## 主な使用ライブラリ
- YetAnotherHttpHandler
  - Unity で利用できる HTTP/2 クライアント 
- MagicOnion
  - HTTP/2 サーバーとして利用できる！
- OpenSSL 3.2.0
  - 証明書を発行できるツール
  - OpenSSL 3 系である必要があります
  - YetAnotherHttpHandler は脆弱性の存在する OpenSSL 1 系で生成した証明書は信頼しません。


# 手順

## MagicOnion Server と Unity Client の準備

MagicOnion Server と Unity Client（YetAnotherHttpHandler）の一例として以下のリポジトリを clone して利用します。
- MagicOnion Server
  - [tou-tou/magiconion-sample-server](https://github.com/tou-tou/magiconion-sample-server)
- Unity Client
  - [tou-tou/magiconion-sample-client](https://github.com/tou-tou/magiconion-sample-client)
  
## (必要な人は) Ubuntu 20.04 で OpenSSL 3 系へ更新

OpenSSL 1.1.1 で生成した証明書だと YetAntherHttpHandler が証明書検証時に以下のようにバージョンをサポートしてない旨のエラーを出力してしまいます。
そのため、OpenSSL 3 系に更新する必要があります。
```
HttpRequestException: error trying to connect: invalid peer certificate: Other(UnsupportedCertVersion)
```

:::message
Ubuntu 20.04 は サポート終了した（2023/09/11）OpenSSL1.1.1 がインストールされているので、最新版に更新します。
:::

[Ubuntu 20.04 で OpenSSL 3.2.0 に更新する](https://zenn.dev/toutou/articles/c14d73c458f18d) を参考に更新します。

以下のように OpenSSL のバージョンが 3.2.0 以上であれば OK です。
```
$  openssl version
OpenSSL 3.2.0 23 Nov 2023 (Library: OpenSSL 3.2.0 23 Nov 2023)
```


## 証明書の作成
pfx と key と crt を生成します。



まずは、サーバープロジェクトに移動します。

例えば、`Ubuntu` へ`bash`でログインし、 magiconion-sample-server に移動します。 

### Windows のホストファイルを編集

管理者権限でhostファイルをメモ帳などで開きます。
例えば以下を追記します。

```
127.0.0.1 dummy.example.com
```

### 秘密鍵の生成です。
```bash:bash
# path-to magiconion-sample-server
mkdir Server/certificate
cd Server/certificate
openssl genrsa 4096 > server.key
```


### 設定ファイルをもとに証明書を生成します

subjectAltNameを設定する必要があります。これがない場合、YetAnotherHttpHandlerは証明書検証時に以下のエラーを出力します。

```
HttpRequestException: error trying to connect: invalid peer certificate: UnknownIssuer
```

設定ファイルを例えば以下のようにします。

```cnf:myssl.cnf
[ req ]
default_bits       = 4096
default_md         = sha256
prompt             = no
encrypt_key        = no
distinguished_name = dn

[ dn ]
CN=dummy.example.com

[ ext ]
basicConstraints=CA:FALSE
keyUsage=digitalSignature, keyEncipherment
subjectAltName=@alt_names

[ alt_names ]
DNS.1=dummy.example.com
DNS.2=www.dummy.example.com
```

```bash:bash
openssl req -new -x509 -key server.key -out server.crt -days 7300 -config myssl.cnf -extensions ext
```

### サーバー用 pfx ファイルの生成
pfxファイルとは...

```bash:bash
openssl pkcs12 -export -out server.pfx -inkey server.key -in server.crt
```

appsettigs.json に秘密鍵とcsrの場所を定義しておけばいけると思ったがなぜかだめだった。pfxファイルを生成してprogram.csで読み込まなければいかないっぽいなぜか、までは調べる余力がなかったです...

### 証明書の確認
```bash:bash
 openssl x509 -in server.crt -text -noout
 Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            48:9a:ec:0f:5f:af:7d:6a:69:b0:d4:57:1e:a2:41:13:57:fe:62:e9
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=dummy.example.com
        Validity
            Not Before: Jan  8 10:31:28 2024 GMT
            Not After : Jan  7 10:31:28 2025 GMT
        Subject: CN=dummy.example.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (4096 bit)
                Modulus:
                    00:9b:16:ad:a6:1f:11:fc:c4:7a:77:46:49:6b:0d:
                    ...(省略)
                    2d:8d:f9
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Basic Constraints:
                CA:FALSE
            X509v3 Key Usage:
                Digital Signature, Key Encipherment
            X509v3 Subject Alternative Name:
                DNS:dummy.example.com, DNS:www.dummy.example.com
            X509v3 Subject Key Identifier:
                A4:A8:BA:AF:16:C7:00:FE:98:A2:B8:10:9B:B9:77:60:15:2D:5B:3E
    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        4e:90:0f:e9:0a:f6:1b:24:72:44:b1:be:07:95:62:e4:2f:b9:
        ...(省略)
        f7:21:e1:74:e5:e7:b9:9c
 ```

# サーバーの設定
サンプルリポジトリの場合、`Program.cs`、`Server.csproj`


## サーバーの実装
```json:appsettigs.json
{
  "Kestrel": {
    "Endpoints": {
      "Grpc": {
        "Url": "http://dummy.example.com:5000",
        "Protocols": "Http2"
      },
      "Https": {
        "Url": "https://dummy.example.com:5001",
        "Protocols": "Http1AndHttp2"
      },
      "Http": {
        "Url": "http://dummy.example.com:5002",
        "Protocols": "Http1"
      }
    }
  }
}
```

# Unity クライアントの設定

Assets/StreamingAssetsを作成し、そこに certificate/server.crt を置きます。


# 動いた


# おわりに


# 参考
- [Configure SSL/TLS | MagicOnion](https://cysharp.github.io/MagicOnion/articles/deployment/https.html#tls-on-localhost)
- [【図解】よく分かるデジタル証明書(SSL証明書)の仕組み 〜https通信フロー,発行手順,CSR,自己署名(オレオレ)証明書,ルート証明書,中間証明書の必要性や扱いについて〜 | SEの道標](https://milestone-of-se.nesuke.com/sv-advanced/digicert/digital-certification-summary/)




# メモ
「MagicOnion と YetAnotherHttpHandler を用いた自己署名証明書による HTTP/2・HTTPS 通信」というタイトルの記事を書く場合、以下の章立てを提案します。この構成は、技術的な詳細を包括的に扱いつつ、読者にとって分かりやすくすることを目的としています。

### 記事の構成案

1. **はじめに**
   - 記事の目的と概要の説明。
   - MagicOnion と YetAnotherHttpHandler の簡単な紹介。

2. **技術的背景**
   - HTTP/2 と HTTPS の基本と重要性。
   - 自己署名証明書の役割と限界。

3. **MagicOnion の概要**
   - MagicOnion の主な特徴と利点。
   - HTTP/2 におけるMagicOnionの役割。

4. **YetAnotherHttpHandler の概要**
   - YetAnotherHttpHandler の特徴と、なぜこれを選んだかの説明。

5. **自己署名証明書の生成と設定**
   - 自己署名証明書の生成方法。
   - MagicOnion と YetAnotherHttpHandler における証明書の設定方法。

6. **HTTP/2 と HTTPS による通信の実装**
   - MagicOnion と YetAnotherHttpHandler を使用してHTTPS通信を設定する手順。
   - サンプルコードと実装の説明。

7. **セキュリティ上の考慮事項**
   - 自己署名証明書の使用に伴うリスク。
   - 安全な通信を確保するためのベストプラクティス。

8. **パフォーマンステストと評価**
   - 実装したシステムのパフォーマンステスト方法。
   - テスト結果とその分析。

9. **まとめと今後の展望**
   - 記事の要点の再確認。
   - 今後の技術的な進展や予想されるトレンド。

10. **参考文献**
    - 記事執筆に使用した資料、参考にした文献のリスト。

### 補足
- **読者層の特定**: 記事の対象読者（例えば、中級から上級の開発者など）を特定し、そのレベルに合わせた言葉遣いや説明の深さを調整する。
- **図表の活用**: 技術的な内容を視覚的に示すために、図表やフローチャートを活用する。
- **実例の提供**: 実際のシナリオに基づく例を提供して、理論的な説明を補完する。

この章立ては、技術的な深さと読みやすさのバランスを取りながら、主題に関する包括的な理解を提供することを目的としています。